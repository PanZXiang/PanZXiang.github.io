[{"categories":null,"content":"1.Socket通信 ","date":"2022-12-09","objectID":"/first_post/:0:0","tags":null,"title":"1.Socket通信","uri":"/first_post/"},{"categories":null,"content":"Socket技术： 服务端 创建两个文件描述符，一个用于创建监听套接字，一个用于服务端与客户端之间连接成功后传输数据的套接字； 创建服务端地址结构，指定服务端的IP协议簇、IP地址和端口号； 将监听套接字与服务端的地址信息进行绑定，调用函数为bind()； 将监听套接字设定为监听状态，开始监听，并且设定同时连接数上限，所有连接请求将放在一个连接请求队列里面，调用函数listen()； 在监听套接字处的连接请求队列中，取出第一个连接请求来建立连接，如果没有连接请求则会一直阻塞，调用函数accept()，如果连接成功则会返回这个新连接的套接字，这个表征新连接的套接字才表示一个成功的连接，后续的数据传输都是通过这个套接字进行的。通过accept()函数可获得成功接入的客户端的地址结构； 上述流程都执行成功后，说明服务端与客户端连接成功，就可以使用read()读取客户端发来的信息，write()向客户端进行信息写入了。（read和write都是使用新连接的套接字） 服务端 创建一个文件描述符，用于创建套接字，客户端无需监听，这个套接字直接用于数据传输； 创建将要连接的服务端的地址结构，指定服务端的IP协议簇、IP地址和端口号； 通过套接字以及服务端的地址结构向服务端发起连接请求，调用函数connect()； 上述流程都执行成功后，说明服务端与客户端连接成功，connect时调用的套接字就保存着此次成功连接的信息，然后就可以使用这个套接字以及read()读取服务端发来的信息，write()向服务端进行信息写入了。 ","date":"2022-12-09","objectID":"/first_post/:1:0","tags":null,"title":"1.Socket通信","uri":"/first_post/"},{"categories":null,"content":"运行结果: 在一个终端中运行服务端并等待客户端连接 在另一个终端启动客户端并加上连接IP和端口 连接完成后可进行客户端与服务端的通信 客户端在发送后返回大写的输入文本 ","date":"2022-12-09","objectID":"/first_post/:2:0","tags":null,"title":"1.Socket通信","uri":"/first_post/"},{"categories":null,"content":"Server: #include \u003ciostream\u003e #include \u003cunistd.h\u003e #include \u003csys/socket.h\u003e #include \u003carpa/inet.h\u003e #include \u003cstring.h\u003e #include \u003cerrno.h\u003e #define SERV_PORT 8888 //服务器端口 #define SERV_IP \"127.1.1.1\" //服务器ip using namespace std; int main(int argc,char** argv) { int servfd,clitfd; //创建两个文件描述符，servfd为监听套接字，clitfd用于数据传输 struct sockaddr_in serv_addr,clit_addr; //创建地址结构体，分别用来存放服务端和客户端的地址信息 memset(\u0026serv_addr,0,sizeof(serv_addr)); //初始化 memset(\u0026clit_addr,0,sizeof(clit_addr)); //初始化 if((servfd = socket(AF_INET,SOCK_STREAM,0)) == -1) //创建套接字 { cout\u003c\u003c\"creat socket failed : \"\u003c\u003cstrerror(errno)\u003c\u003cendl;//如果出错则打印错误 return 0; } //给服务端的地址结构体赋值 serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(SERV_PORT); //将主机上的小端字节序转换为网络传输的大端字节序（如果主机本身就是大端字节序就不用转换了） serv_addr.sin_addr.s_addr = inet_addr(SERV_IP); //将字符串形式的ip地址转换为点分十进制格式的ip地址 //绑定地址信息到监听套接字上，第二个参数强转是因为形参类型为sockaddr ，而实参类型是sockaddr_in 型的 if(bind(servfd,(sockaddr *)\u0026 serv_addr,sizeof(serv_addr)) == -1) { cout\u003c\u003c\"bind failed : \"\u003c\u003cstrerror(errno)\u003c\u003cendl; return 0; } //将servfd套接字置为监听状态 if(listen(servfd,1024) == -1) { cout\u003c\u003c\"listen failed : \"\u003c\u003cstrerror(errno)\u003c\u003cendl; return 0; } cout\u003c\u003c\"Init Success ! \"\u003c\u003cendl; cout\u003c\u003c\"ip : \"\u003c\u003cinet_ntoa(serv_addr.sin_addr)\u003c\u003c\" port : \"\u003c\u003cntohs(serv_addr.sin_port)\u003c\u003cendl; cout\u003c\u003c\"Waiting for connecting ... \"\u003c\u003cendl; socklen_t clit_size = 0; //用于accept函数中保存客户端的地址结构体大小 //accept成功后，clitfd则指向了这条服务端与客户端成功连接的”通路“ if((clitfd = accept(servfd,(sockaddr *)\u0026 clit_addr,\u0026clit_size)) == -1) { cout\u003c\u003c\"accept failed : \"\u003c\u003cstrerror(errno)\u003c\u003cendl; return 0; } cout\u003c\u003c\"Client access : \"\u003c\u003cinet_ntoa(clit_addr.sin_addr)\u003c\u003c\" \"\u003c\u003cntohs(clit_addr.sin_port)\u003c\u003cendl; char buf[1024]; //用于读写数据 while(1) { int rdstate; if((rdstate = read(clitfd,buf,sizeof(buf))) \u003e 0 )//通过clitfd来读取数据，返回值为读取的长度 { int i=0; cout\u003c\u003c\"(Server)recv : \"; for(i=0;i\u003crdstate;i++) { cout\u003c\u003cbuf[i]; buf[i] = toupper(buf[i]); //转换为大写 } buf[i]='\\0'; cout\u003c\u003cendl; write(clitfd,buf,strlen(buf)); //发回客户端 } else if(rdstate == 0) //客户端退出 { cout\u003c\u003c\"client exit ! \"\u003c\u003cendl; return 0; } } close(servfd); //关闭套接字 close(clitfd); return 0; } ","date":"2022-12-09","objectID":"/first_post/:3:0","tags":null,"title":"1.Socket通信","uri":"/first_post/"},{"categories":null,"content":"Client: #include \u003ciostream\u003e #include \u003cunistd.h\u003e #include \u003csys/socket.h\u003e #include \u003carpa/inet.h\u003e #include \u003cstring.h\u003e #include \u003cerrno.h\u003e #include \u003ccstdio\u003e using namespace std; int main(int argc,char** argv) { int clitfd; //文件描述符 struct sockaddr_in serv_addr; //目的服务端地址结构体 memset(\u0026serv_addr,0,sizeof(serv_addr)); if(argc!=3) { cout\u003c\u003c\"Input error! Usage should be : \"\u003c\u003cargv[0]\u003c\u003c\" xxx.xxx.xxx.xxx(ip) 1234(port)\"\u003c\u003cendl; return 0; } if((clitfd = socket(AF_INET,SOCK_STREAM,0)) == -1) //创建套接字 { cout\u003c\u003c\"creat socket failed : \"\u003c\u003cstrerror(errno)\u003c\u003cendl; return 0; } //将目的服务端的地址信息赋值给地址结构体 serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(atoi(argv[2])); serv_addr.sin_addr.s_addr = inet_addr(argv[1]); cout\u003c\u003c\"try to connect ... \"\u003c\u003cendl; //通过套接字发起连接请求，成功后clitfd套接字则表示此次成功的连接 if( connect(clitfd,(struct sockaddr*)\u0026 serv_addr,sizeof(serv_addr)) == -1) { cout\u003c\u003c\"connet failed : \"\u003c\u003cstrerror(errno)\u003c\u003cendl; return 0; } cout\u003c\u003c\"connect success !\"\u003c\u003cendl; while(1) { char sdbuf[1024]; char rvbuf[1024]; int rdlen,sdlen,i=0; cout\u003c\u003c\"(Client)send : \"; while((sdbuf[i] = getchar()) != '\\n')i++; if(i==0)continue; //防止客户端只发一个换行符，此时i=0，write不发送数据，服务端就不回回发数据，然后客户端就一直阻塞在read处。因此如果i=0，则直接重新输入 sdlen = write(clitfd,sdbuf,i); //向套接字中写入数据发送 //可能会出现发送端把长度为sdlen的字符串分为多次发送，调用一次read就很有可能不能读取完全，就有以下两种方式进行读取： /*1. write了多少字节就读取多少字节长的字符串*/ rdlen=0; while(rdlen\u003csdlen)//防止发送端将数据分开发送 { int rdcnt = read(clitfd,\u0026rvbuf[rdlen],sizeof(rvbuf)); if(rdcnt == -1) { perror(NULL); continue; } rdlen+=rdcnt; } if(rdlen) { rvbuf[rdlen]='\\0'; cout\u003c\u003c\"(Client)recv : \"\u003c\u003crvbuf\u003c\u003cendl; } else { cout\u003c\u003c\"Server has closed ! \"\u003c\u003cendl; cout\u003c\u003c\"Client will close...\"\u003c\u003cendl; break; } /*2. 用recv函数中的MSG_WAITALL参数，读到指定长度的数据才返回*/ /*if(rdlen = recv(clitfd,\u0026rvbuf[rdlen],sdlen,MSG_WAITALL)) { rvbuf[rdlen]='\\0'; cout\u003c\u003c\"(Client)recv : \"\u003c\u003crvbuf\u003c\u003cendl; } else { cout\u003c\u003c\"Server has closed ! \"\u003c\u003cendl; cout\u003c\u003c\"Client will close...\"\u003c\u003cendl; break; }*/ } close(clitfd); } ","date":"2022-12-09","objectID":"/first_post/:4:0","tags":null,"title":"1.Socket通信","uri":"/first_post/"},{"categories":null,"content":"1.本地安装并远程连接gitee仓库 sudo apt-get install git git init //选择文件夹初始化为本地仓库 git config –global user.email “xx@xx.com” git config –global user.name “xxx” //配置用户邮箱和名字 ssh-keygen -t rsa -C “xx@xx.com” //获取ssh公钥 it remote add origin “git仓库网址” // ssh -T git@gitee.com //验证是否连接成功 2.从本地仓库提交远程仓库 git add xx //上传代码文件 git commit -m ‘描述’ //将上传代码文件打包并记录 git push origin “仓库名” ","date":"2022-12-09","objectID":"/second_post/:0:0","tags":null,"title":"2.Git记录代码并上传仓库","uri":"/second_post/"},{"categories":null,"content":"pwd 显示当前工作目录绝对路径 ","date":"2022-12-09","objectID":"/third_post/:0:1","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"cd 改变工作目录路径 . 代表当前所在目录 .. 代表当前目录的上一层目录 ~ 代表家目录 / 代表根目录 ","date":"2022-12-09","objectID":"/third_post/:0:2","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"mkdir 创建目录 -p 若路径中目录不存在则先创建目录 ","date":"2022-12-09","objectID":"/third_post/:0:3","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"ls 列出目录和文件信息 -l 列出详细信息 -a 显示所有文件（包括隐藏文件） -d 查看目录属性 -h 以易于阅读格式输出文件大小，与-l一起 ","date":"2022-12-09","objectID":"/third_post/:0:4","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"rmdir 删除空目录 ","date":"2022-12-09","objectID":"/third_post/:0:5","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"touch 创建空文件、更改文件时间 ","date":"2022-12-09","objectID":"/third_post/:0:6","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"cp 复制文件或目录 cp old.txt ../new/ ","date":"2022-12-09","objectID":"/third_post/:0:7","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"touch 创建文件 ","date":"2022-12-09","objectID":"/third_post/:0:8","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"rm 删除文件或文件夹 ","date":"2022-12-09","objectID":"/third_post/:0:9","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"find 查找文件 -name 匹配文件名称 -type 匹配文件类型(f普通文件，d目录) -size 匹配文件大小(+50k,+3G) find /user/bin -name \"host\" -type f -size +1M ","date":"2022-12-09","objectID":"/third_post/:0:10","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"cat * 显示文件内容、链接文件内容 ","date":"2022-12-09","objectID":"/third_post/:0:11","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"head、tail 显示文件头、尾数据 tail/head -n 3 /etc/passwd ","date":"2022-12-09","objectID":"/third_post/:0:12","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"grep 全局查找以及打印 -i 查找时忽略大小写 -n 显示行号 -r 递归搜索子目录 -v 反向查找，查找与条件不符的行 grep user -irn /etc/ ","date":"2022-12-09","objectID":"/third_post/:0:13","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"重定向 « 标准输入,代码为0 or » 标准输出,代码为1,»为追加 2\u003e or 2» 标准错误输出,代码为2,2»为追加 ","date":"2022-12-09","objectID":"/third_post/:0:14","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"修改权限 chmod /config.toml 777权限分别为用户、组、其他 ","date":"2022-12-09","objectID":"/third_post/:0:15","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"Vim编辑器 i 插入 Esc 退出插入 :w/:q/:wq/q! 保存/退出/保存并退出/强制退出 数字0 跳转至行首 $ 跳转到行尾 gg 跳转到文件首行 G 跳转到文件的末尾行 #gg 跳转到文件第#行 x 删除光标处字符 dd 删除所在行 #dd 删除从光标开始#行 r 替换单个字符 R 替换多个字符 yy 复制光标所在行 #yy 复制光标开始#行 p 粘贴 u 撤销操作 ","date":"2022-12-09","objectID":"/third_post/:0:16","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"磁盘管理 lsblk查看当前所有磁盘 parted磁盘分区 sudo paered 磁盘路径 进入parted进行分区 mklabel gpt 创建新的分区表 mkpart part1 0% 10G 创建从0到10G的分区 mkpart part2 10G 100% 创建10G到全部空间的分区 rm 删除分区 创建并手动挂载文件系统 sudo mkfs -t ext4 磁盘路径 sudo mount 磁盘路径 挂载文件夹路径 LVM(逻辑卷管理) 管理物理卷(PV,Physical Volumes) pvcreate 磁盘路径 创建物理卷 pvs或pvidsplay 查看物理卷 pvremove 磁盘路径 删除物理卷 管理卷组(VG,Volume Group) vgcreate 卷组名 磁盘路径 创建卷组 vgextend 卷组名 磁盘路径 扩展卷组 vgreduce 卷组名 磁盘路径 收缩卷组 vgremove 卷组名 磁盘路径 删除卷组 管理逻辑卷(LV,Logical Volumns) -L 制定逻辑卷大小 -n 指定逻辑卷名称 lvcreate -L 10G -n 逻辑卷名 卷组名 创建逻辑卷 lvextend/lvreduce -L +/-10G 逻辑卷路径 扩展/收缩逻辑卷 lvremove 逻辑卷路径 删除逻辑卷 ","date":"2022-12-09","objectID":"/third_post/:0:17","tags":null,"title":"3.Linux学习笔记","uri":"/third_post/"},{"categories":null,"content":"Git、Socket、Hugo学习及应用 本次大作业中首先在Ubuntu系统中完成Socket通信,在使用Hugo时遇到权限不足的bug后改为使用Kali系统完成,并且在两个系统中都配置了Git远程连接仓库 ","date":"2022-12-09","objectID":"/forth_post/:0:0","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"1.Git应用 ","date":"2022-12-09","objectID":"/forth_post/:1:0","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"运行git init初始化仓库并且会出现 .git文件 ","date":"2022-12-09","objectID":"/forth_post/:1:1","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"编写好代码后使用git add与git commit命令提交文件 ","date":"2022-12-09","objectID":"/forth_post/:1:2","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"使用git log查看提交记录 ","date":"2022-12-09","objectID":"/forth_post/:1:3","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"使用git push origin master提交到远程仓库 ","date":"2022-12-09","objectID":"/forth_post/:1:4","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"学习网站 https://gitee.com/help/categories/36 https://blog.csdn.net/qq_43794633/article/details/120625061 ","date":"2022-12-09","objectID":"/forth_post/:1:5","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"2.Socket通信 ","date":"2022-12-09","objectID":"/forth_post/:2:0","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"最先使用python语言编写，由于Ubuntu中python版本过低，改为c++编写 ","date":"2022-12-09","objectID":"/forth_post/:2:1","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"通过学习了解到Socket客户端中主要使用函数bind()对IP与端口绑定并使用函数listen()开始监听请求，存在请求使用accpet()函数进行连接，成功则返回客户端的Socket，通过函数read()读取客户端发来的信息，函数write()向客户端输送信息。 ","date":"2022-12-09","objectID":"/forth_post/:2:2","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"学习网站 https://www.bilibili.com/video/BV1a7411z75u?p=1\u0026vd_source=f119c843c853cb3b12ba5f4844e23e89 https://www.bilibili.com/video/BV1DV4y1j7SC/?spm_id_from=333.337.search-card.all.click\u0026vd_source=f119c843c853cb3b12ba5f4844e23e89 ","date":"2022-12-09","objectID":"/forth_post/:2:3","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"3.Hugo个人博客搭建 ","date":"2022-12-09","objectID":"/forth_post/:3:0","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"使用hugo new site 名字搭建本地站点 ","date":"2022-12-09","objectID":"/forth_post/:3:1","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"前往 https://themes.gohugo.io/选择主题 ","date":"2022-12-09","objectID":"/forth_post/:3:2","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"对站点内config文件配置对应主题和其他参数 ","date":"2022-12-09","objectID":"/forth_post/:3:3","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"使用hugo new posts/first_post.md获取一个文章 ","date":"2022-12-09","objectID":"/forth_post/:3:4","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"使用hugo server启动本地网站 ","date":"2022-12-09","objectID":"/forth_post/:3:5","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"使用markdown语法对文章进行编辑 ","date":"2022-12-09","objectID":"/forth_post/:3:6","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"学习网站 https://hugoloveit.com/zh-cn/theme-documentation-basics/ https://www.bilibili.com/video/BV1JA411h7Gw/?spm_id_from=333.337.search-card.all.click\u0026vd_source=f119c843c853cb3b12ba5f4844e23e89 ","date":"2022-12-09","objectID":"/forth_post/:3:7","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"4.将Hugo网页通过Apache部署到服务器 ","date":"2022-12-09","objectID":"/forth_post/:4:0","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"在站点中使用hugo在public生成配置文件 ","date":"2022-12-09","objectID":"/forth_post/:4:1","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"将public中的文件复制到/var/www/html中 ","date":"2022-12-09","objectID":"/forth_post/:4:2","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"使用/etc/init.d/apache2 start开启Apache服务 ","date":"2022-12-09","objectID":"/forth_post/:4:3","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"网页中输入IP地址即可访问 ","date":"2022-12-09","objectID":"/forth_post/:4:4","tags":null,"title":"4.完成步骤","uri":"/forth_post/"},{"categories":null,"content":"学习网站 https://blog.csdn.net/Fighting_hawk/article/details/122640537 ","date":"2022-12-09","objectID":"/forth_post/:4:5","tags":null,"title":"4.完成步骤","uri":"/forth_post/"}]